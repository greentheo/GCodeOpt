{
    "contents" : "library(EBImage)\n#library(rgl)\nlibrary(Matrix)\nlibrary(pixmap)\npicSet = 'firehydrant'\npicSet = 'house'\npicSet = 'bookShelves'\npicSet = 'chair'\n\nfiles = list.files(path=paste('picsets/', picSet, sep='',collapse=''),full.names=T)\nimg = vector(\"list\", length(files))\nfor(f in 1:length(files)){\n  img[[f]][[\"img\"]] = readImage(files[f])\n  \n  #correct for the rotation (pitch of the picture)\n  sensor=strsplit(gsub('.jpg','',files[f]), '_')[[1]]\n  \n  img[[f]][[\"sensor\"]] = sensor[c(4,6,8)]\n  names(img[[f]][[\"sensor\"]]) = sensor[c(3,5,7)]\n  \n}\n  \n#plot pictures and picture diffs\nplotPic = function(img){\n  bw = imageData(flip((img)))\n  bw = (bw[,,1]+bw[,,2]+bw[,,3])/3\n  image(bw, col=seq(0,1, length.out=2))\n}\nplotPicDiff = function(img1, img2){\n  bw1 = imageData(flip(img1))\n  bw1 = (bw1[,,1]+bw1[,,2]+bw1[,,3])/3\n  \n  bw2 = imageData(flip(img2))\n  bw2 = (bw2[,,1]+bw2[,,2]+bw2[,,3])/3\n  \n  image(bw1-bw2, col=heat.colors(10))\n  \n#   browser()\n#   surface3d(x=1:nrow(bw1), y=1:ncol(bw1), z=bw1-bw2)\n}\n\nfindMatches=function(img1, img2, gps = 30, df=60, skip=5){\n  #gps = grid filter size (the size of the grid to find points on)\n  #df = difference Filter so you don't have to compare each grid to all grids.. .just ones close by\n  \n  #threshold for easier analysis (at first)\n  bw1 = imageData(flip(resize(img1,w=dim(img1)[1]/4)))\n  bw1 = (bw1[,,1]+bw1[,,2]+bw1[,,3])/3\n  #bw1 = ifelse(bw1>mean(bw1), 0, 1)\n  \n  bw2 = imageData(flip(resize(img2, w=dim(img2)[1]/4)))\n  bw2 = (bw2[,,1]+bw2[,,2]+bw2[,,3])/3\n  #bw2 = ifelse(bw2>mean(bw2), 0, 1)\n  \n  #divide up the first image into points with features\n  colInd = seq.int((1),(nrow(bw1)-gps+1), by=skip)\n  rowInd = seq.int((1),(ncol(bw1)-gps+1), by=skip)\n  feats1 = array(0, c(length(colInd)*length(rowInd), gps^2+2))\n  feats2 = feats1\n  count=1\n  for(j in colInd){\n    for(i in rowInd){\n      feats1[count,] = c(i,j, as.numeric(bw1[j:(j+gps-1),i:(i+gps-1)]))  \n      feats2[count,] = c(i,j, as.numeric(bw2[j:(j+gps-1), i:(i+gps-1)]))\n      count = count+1\n    }\n  }\n  \n  #calculate a similarity score for all feature rows \n  featCor = Matrix(0,nrow=nrow(feats1), ncol=nrow(feats2))\n  progessBar = txtProgressBar(min=0, max=nrow(feats1))\n  for(i in 1:nrow(feats1)){\n    setTxtProgressBar(progessBar, i)\n    indFilt = which(feats2[,1]<(feats1[i,1]+df) & \n                      feats2[,1]>(feats1[i,1]-df) &\n                      feats2[,2]<(feats1[i,2]+df) &\n                      feats2[,2]>(feats1[i,2]-df) )\n    \n    cors = sapply(indFilt, function(x){\n      cor(feats2[x, 3:ncol(feats1)], feats1[i,3:ncol(feats1)])\n    })    \n    cors[is.na(cors)] = -1\n      featCor[i,indFilt] = cors \n#       featCor[i,indFilt] = rowMeans(exp(abs(matrix(feats1[i,3:ncol(feats1)], nrow=length(indFilt), ncol=ncol(feats1)-2, byrow=T)\n#                                     -feats2[indFilt,3:ncol(feats1)])) )\n  } \n  \n  #now take the best match for each point\n  #filter out anything less than the .3 correlation and only use those as comparison points\n  #sigInd = which(featCor<.3)\n  matches = max.col(featCor)\n  \n  #now we can only allow a unique match... so select best match value\n  \n  featCor[is.na(featCor)]=-1\n  matchInd = which(diag(featCor[,matches])>.75)\n  match1Y = feats1[c(1:nrow(feats1))[matchInd], 1]\n  match1X = feats1[c(1:nrow(feats1))[matchInd], 2]\n  match2Y = feats2[matches[matchInd], 1]\n  match2X = feats2[matches[matchInd], 2]\n  \n  image(1:nrow(bw1), 1:ncol(bw1), bw1,col=gray(seq(0,1, by=.05)))\n  Yflip =max(match1Y)-match1Y+1\n  points((match1X), Yflip, pch=1:length(matchInd), col=\"blue\")\n  rect(xleft=match1X,xright=match1X+gps-1, ytop=Yflip, ybottom=Yflip-gps+1, border=\"red\")\n  \n  image(1:nrow(bw2), 1:ncol(bw2),bw2, col=gray(seq(0,1, by=.05)))\n  Yflip = max(match2Y)-match2Y+1\n  points(match2X, Yflip, pch=1:length(matchInd), col=\"blue\")\n  rect(xleft=match2X,xright=match2X+gps-1, ytop=Yflip, ybottom=Yflip-gps+1, border=\"red\")\n  \n  #plot a bunch of examples of matches\n pdf('results/featCompare.pdf')\n  for(i in 1:10){#length(matchInd)){\n    bwSub1 = bw1[match1X[i]:(match1X[i]+gps-1), match1Y[i]:(match1Y[i]+gps-1)]\n    image(1:nrow(bwSub1), 1:ncol(bwSub1), bwSub1,col=gray(seq(0,1, by=.05)), main=\"img1\")\n   \n    bwSub2 = bw1[match2X[i]:(match2X[i]+gps-1), match2Y[i]:(match2Y[i]+gps-1)]\n    image(1:nrow(bwSub2), 1:ncol(bwSub2), bwSub2,col=gray(seq(0,1, by=.05)), main=\"img2\")\n    \n    image(1:nrow(bwSub2), 1:ncol(bwSub2), bwSub2-bwSub1,col=gray(seq(0,1, by=.05)), main=\"subtract\")\n    \n  }\n  dev.off()\n}\n\nplotPic(img[[1]]$img)\nplotPic(img[[2]]$img)\nplotPicDiff(img[[1]]$img, img[[2]]$img)\nplotPicDiff(img[[2]]$img, img[[3]]$img)\nplotPicDiff(img[[3]]$img, img[[4]]$img)\n\nimg1 = img[[1]]$img\nimg2 = img[[2]]$img\n\ngps = 30\ndf = 10\nskip=3\nskip=3",
    "created" : 1428158764779.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3952919881",
    "id" : "E517D73A",
    "lastKnownWriteTime" : 1394510956,
    "path" : "~/githubrepo/2dTo3dAndroid/2dTo3dR/processPics.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}